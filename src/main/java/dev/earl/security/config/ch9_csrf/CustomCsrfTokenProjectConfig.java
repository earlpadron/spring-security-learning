//package dev.earl.security.config.ch9_csrf;
//
//import dev.earl.security.repository.CustomCsrfTokenRepository;
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.security.config.annotation.web.builders.HttpSecurity;
//import org.springframework.security.web.SecurityFilterChain;
//import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
//
//@Configuration
//public class CustomCsrfTokenProjectConfig {
//
//    private final CustomCsrfTokenRepository customCsrfTokenRepository;
//
//    public CustomCsrfTokenProjectConfig(CustomCsrfTokenRepository customCsrfTokenRepository) {
//        this.customCsrfTokenRepository = customCsrfTokenRepository;
//    }
//
//    @Bean
//    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
//        http.csrf(c -> {
//            c.csrfTokenRepository(customCsrfTokenRepository);
//            /**
//             * SIDE NOTE:
//             * You can customize the simple behavior of the
//             * CsrfTokenRequestAttributeHandler object by extending its class. For
//             * example, the default implementation Spring Security uses (named
//             * XorCsrfTokenRequestAttributeHandler) has a more complex behavior.
//             * This implementation generates a random value using a SecuredRandom object
//             * and then mixes its byte array with the token generated by the
//             * CsrfTokenRepository using an XOR logic operation
//             */
//            c.csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler());
//        }); //configure our own token repository
//        http.authorizeHttpRequests(c -> c.anyRequest().permitAll());
//        return http.build();
//
//    }
//}
